#include <iostream>
#include <math.h>

using namespace std;

	struct _intListNode
	/*Структура _intListNode (a node of list of integers) -- это элемент листа целочисленных переменных. Он несёт в себе информацию о значении этого элемента списка (value), о предыдущем элементе списка (previous) и о последующем элементе списка (next). Если элемент в списке первый, то есть перед ним ничего не идёт, то previous = NULL. Соответственно, если элемент в списке последний, то есть после него ничего нет, то next = NULL*/
	{
		int value; // -- значение элемента (целочисленное)
		_intListNode* previous; // -- ссылка на предыдущий элемент
		_intListNode* next; // -- ссылка на последующий элемент
	};
	struct intList 
	/*Структура intList (list of integer) --это непосредственно список. Благодаря этой структуре в программе можно вызывать сколько угодно списков, а не создавать каждый с нуля из элементов списка. Структура списка несёт в себе информацию о первом элементе списка (first), о последнем элементе списка (last) и о длине списка, то есть количестве элементов в списке (не путать с номером последнего элемента, так как список тоже нумеруется с нуля) (length). Если список пуст, то его длина равна нулю, first = NULL и last = NULL. Все последующие операции (функции) выполняются со списками.*/
	{
		_intListNode* first; // -- ссылка на первый элемент
		_intListNode* last; // -- ссылка на последний элемент
		int length; // -- количество элементов в списке (целочисленное)
	};
	intList createList () 
	/*Функция createList (create a list) выполняет за вас нудную работу при создании списка и сразу создаёт новый пустой список с занулёнными первым и последним элементом и нулевой длиной. В теории так же может использоваться, чтобы опустошить список, то есть выкинуть из него все элементы. Разумеется, при этом элементы не исчезнут, они будут засорять память и стоять без дела, просто вне списка
	Служебные обозначения: thislist -- "этот список" или просто список с которым мы работаем*/
	{
		intList *thislist = new intList; // -- создаётся новый список, проживающий по адресу thislist
		thislist -> first = NULL; // -- первый элемент зануляется
		thislist -> last = NULL; // -- последний элемент зануляется
		thislist::length = 0; // -- количество элементов в списке равно нулю
		return *thislist; // -- возвращаем пустой список
	}
	_intListNode findNode (intList *thislist, int number) 
	/*Функция findNode (find a node) -- это функция, возвращающая элемент списка под некоторым номером. Возвращает именно элемент как структуру данных, а не его значение, по этому на практике практически не применима, используется в основном в других функциях. Может быть использована для вывода и значений элементов через функцию getValue (ниже) или в ручную, как будет ещё показано. На вход получает список, в котором нужно найти элемент и номер элемента, который нужно найти. Возвращает элемент.
	Служебные обозначения: thislist -- "этот список" или список с которым мы работаем, number -- "номер", номер элемента, который нас интересует (номерация начинается с нуля), thenode -- "Элемент" или просто тот элемент, с которым мы работаем */
	{
		_intListNode *thenode = new _intListNode; // -- создаётся thenode, временная переменная
		if (thislist -> first != NULL) //-- проверка не пустой ли этот список
		{								// -- если этот список не пустой, то
			thenode = thislist -> first; // -- изначально Элемент получает информацию первого элемента списка
			if (number < thislist -> length) // -- проверяем, находится ли искомый номер вообще в рамках индексации этого списка
			{									// -- если в списке действительно есть такой элемент, то
				for (int i = 0; i < number; i++) // --начиная с элемента №0 и до искомого номера
				{
					thenode = thenode -> next; // -- рассматриваем следующий и следующий элемент
				}								       // -- пока не доберёмся до искомого
				return *thenode; // -- выводим искомый элемент
			}
			else // -- если введённый номер больше чем вообще существует элементов в списке
			{
				return *thislist -> last; // то возвращаем последний элемент
			}
		}
		else // -- если же полученный список пустой
		{
			thenode -> value = 0; 
			thenode -> previous = NULL;
			thenode -> next = NULL;
			return *thenode; // -- возвращаем пустой элемент
		}
	}
	int getValue (intList *thislist, int number)
	/*Функция getValue --это простая функция, которая делает работу с листами намного легче. Она позволяет вам сделать с ними то же что и с массивом и просто получить значение элемента под некоторым номером. Я сделал её исключительно ради облегчения работы пользователя со списками, поэтому она нигде особо не используется, но это потому, что весь этот файл -- это внутренние механизмы моего "списка", поэтому не судите строго. На вход принимает список, в котором ищется элемент, номер интересующего элемента, а на выходе получается значение элемента.
	Служебные обозначения: thislist -- "этот лист" или просто лист с которым мы работаем, number -- "номер" или просто номер элемента, который нас интересует, thenode -- "Элемент" или тот элемент, который нас интересует*/
	{
		_intListNode *thenode = new _intListNode; // -- заводим thenode
		*thenode = findNode(thislist, number); // -- передаём ему значения элемента списка под интересуемым номером
		return thenode->value; // -- возвращаем значение этого элемента
	}
	intList addNode (intList *thislist, int value)
	/*Функция addNode (add a node) добавляет элемент в конец списка. Она является частным случаем insertNode (ниже), но легче в ревлизации и используется достаточно часто чтобы быть вынесенной отдельно. На ввод получет список и значение нового элемента, возвращает этот же список, но уже с прибавленным элементом.
	Служебные обозначения: thislist -- "этот лист" или просто лист, с которым мы работаем, value -- "значение" или значение нового элемента, newnode -- "новый элемент" или просто элемент, который мы добавляем к списку*/
	{
		_intListNode *newnode = new _intListNode; // -- заводим newnode
		newnode -> value = value; // -- присваиваем новому элементу его значение
		if (thislist -> first == NULL) // -- проверяем, не пустой ли список
		{								 // -- если список пуст, то
			newnode -> previous = NULL; // -- говорим, что перед новым элементом ничего нет
			newnode -> next = NULL; // -- говорим, что после первого элемента ничего нет
			thislist -> first = newnode; // -- говорим, что новый элемент первый в этом списке
			thislist -> last = newnode; // -- говорим, что новый элемент последний в этом списке
		}
		else // -- если же список не пуст, то
		{
			newnode -> previous = thislist -> last; // -- говорим, что перед новым элементом расположен бывший последний элемент
			newnode -> next = NULL; // -- говорим, что после нового элемента ничего нет
			thislist -> last -> next = newnode; // -- говорим, что для бывшего последним новый элемент последующий
			thislist -> last = newnode; // -- говорим, что новый элемент последний в этом списке
		}
		thislist -> length = thislist -> length + 1;  // -- говорим, что длина этого списка увеличилась
		return *thislist; // -- выводим обновлённый список
	}
	intList cutNode (intList *thislist)
	/*Функция cutNode (cut a node off) убирает из списка последний элемент. Не сказать, что она используется так же часто как добавление нового элемента в конец, но она реализуется как частный случай deleteNode (ниже) проще, так что достойна своей обособленности. На вход подаётся список с которым мы работаем, на выходе выдаётся он же, но уже обрезанный
	Служебные обозначения: thislist -- "этот список" или просто список с которым мы работаем, oldnode -- "старый элемент" или просто удаляемый элемент*/
	{
		if (thislist -> first == NULL) {} // --проверяем не пустой ли этот список, и если пустой, то ничего не делаем
 		else if (thislist -> first == thislist -> last) // -- если же этот список не пустой, то не состоит ли он из всего одного элемента
		{										            // -- если состоит, то просто обнулим его (см. createList)
			thislist -> first = NULL;
			thislist -> last = NULL;
			thislist -> length = 0;
		}
		else // -- если же этот список посолиднее и состоит больше чем из одного элемента, то
		{
			_intListNode *oldnode = new _intListNode; // -- заводим oldnode
			oldnode = thislist -> last; // -- говорим, что последний элемент этого списка и есть старый элемент
			thislist -> last = oldnode -> previous; // -- объявляем последним элементом этого списка элемент перед старым
			thislist -> length = thislist -> length - 1; // -- убавляем длину этого списка на единицу
		}
		return *thislist; // возвращаем изменённый или не очень список
	}
	intList insertNode (intList *thislist, int value, int number) 
	/*Функция insertNode (insert a node) -- это очень полезная функция, позволяющая добавлять новый элемент в список да так, что он становится в нём не последним, а под некоторым номером. Это сразу показывает преимущество списков над массивами, так как мы вообще можем так сделать, не сдвигая весь массив, а лишь поменяв одну-две связки. На вход получает список, значение нового элемента и номер нового элемента.
	Служебные обозначения: thislist -- "этот список" или просто тот список, с которым мы работаем, value -- "значение" или значение нового элемента, number -- "номер" или номер нового элемента, newnode -- "новый элемент" или соответственно, добавляемый нами элемент, prevnode -- "предыдущий элемент" или элемент теперь предшествующий новому элементу, nextnode -- "следующий элемент" или элемент теперь стоящий после нового элемента*/
	{
		if (number < 0) number = 0; // -- если кто-то не знает как добавить элемент в начало списка и решил дать ему отрицательный номер, то тут мы это исправим
		if (thislist -> length == 0) // -- если этот список пустой, то мы просто вызываем добавление элемента в конец (см. addNode)
		{
			*thislist = addNode (thislist, value);
		}
		else if (number == 0) //-- если новый элемент должен стать первым, то 
		{
			_intListNode *newnode = new _intListNode; // -- заводим newnode
			newnode -> value = value; // -- присваиваем ему его значение
			newnode -> previous = NULL; // -- говорим, что перед ним ничего нет
			newnode -> next = thislist -> first; // -- говорим, что после него идёт бывший перый элемент
			thislist -> first -> previous = newnode; // -- говорим, что для бывшего первого новый элемент предшествующий
			thislist -> first = newnode; // -- говорим, что в этом списке новый элемент первый
			thislist -> length = thislist -> length + 1; // -- добавляем к длине этого списка
		}
		else if (number >= thislist -> length) // -- если номер превышает длину этого списка, то просто добавляем элемент в конец
		{
			*thislist = addNode (thislist, value);
		}
		else // -- если же мы хотим добавить новый элемент куда-нибудь в середину этого списка, то
		{
			_intListNode *newnode = new _intListNode; // -- заводим newnode
			_intListNode *prevnode = new _intListNode; // -- заводим prevnode
			_intListNode *nextnode = new _intListNode; // -- заводим nextnode
			*prevnode = findNode (thislist, number-1); // -- говорим, что предыдущий элемент в этом списке лежит под номером н-1
			*nextnode = findNode (thislist, number); // -- говорим, что последующий элемент в этом списке лежит под номнорм н
			newnode -> next = prevnode -> next; // -- говорим, что следующий за новым элементом элемент -- это элемент, который раньше стоял под номером н, то есть после "предыдущего элемента", под номером н-1 
			newnode -> previous = nextnode -> previous; // -- говорим, что предыдущий для нового элемента элемент -- это элемент, котрый раньше стоял под номером н-1, то есть перед "следующим элементом", под номером н
			// замечание: предыдущие две строки обязательно должны стоять перед следующими двумя, так как опираются на старую нумерацию. Дальше же нумерация меняется для поддкржания работоспособности списка.
			newnode -> next -> previous = newnode; // -- говорим, что для следующего после нового элемента новый элемент предыдущий
			newnode -> previous -> next = newnode; // -- говорим, что для предыдущего для нового элемента новый элемент последующий
			newnode -> value = value; // присваиваем новому элементу его значение
			thislist -> length = thislist -> length + 1; // увеличиваем длину списка
		}
		return *thislist; // возвращаем изменённый список
		// замечание: в отличие от предыдущих функций я пишу удлинение списка в скобках, а не после них, так как addNode сама по себе увеличивает длину списка.
	}
	intList deleteNode (intList *thislist, int number) 
	/*Функция deleteNode (delete a node) -- это очень полезная функция, удаляющая элемент с любой позиции в списке. На вход получает список и интересуемый номер, а на выходе даёт уже изменённый список.
	Служебные обозначения: thislist -- "этот список" или список с которым мы работаем, number -- "номер" или номер удаляемого элемента, thenode -- "Элемент" или просто удаляемый элемент*/
	{
		if (number < 0 || number >= thislist -> length){} // -- если номер лежит за пределами индексации списка, не делаем ничего
		else if (thislist -> first == NULL) {} // -- если этот список пуст, то делать тоже нечего
		else if (number == thislist -> length - 1) // -- если номер нас интересующий - последний, то просто убираем с конца
		{
			*thislist = cutNode (thislist);
		}
		else if (number == 0) // -- если нужно убрать первый элемент, то 
		{
			thislist -> first -> next -> previous = NULL; // -- зануляем предыдущий для последующего после первого элемент  
			thislist -> first = thislist -> first -> next; // -- передвигаем начало списка с первого на второй элемент
			thislist -> length = thislist -> length - 1; // -- уменьшаем длину листа
		}
		else // -- если же нужно убрать элемент откуда-то из середины, то
		{
			_intListNode *thenode = new _intListNode; // -- заводим thenode
			*thenode = findNode (thislist, number); // -- присваиваем ему значение элемента с интересующим нас номером
			thenode -> previous -> next = thenode -> next; // -- говорим, что для предыдущего Элементу элемента последующим будет последующий для Элемента элемент
			thenode -> next -> previous = thenode -> previous; // -- говорим, что для последующего для Элемента элемента предыдущим будет предыдущий для Элемента элемент
			thislist -> length = thislist -> length - 1; // -- уменьшаем длину этого списка
		}
		return *thislist; // -- возвращаем изменённый список
	}

int main() // -- далее лежит тело программы, а в данном случае проверка разных функций списка
{
	intList *testlist = new intList; // -- заводим testlist
	*testlist = createList(); // -- обнуляем новый список
	addNode (testlist, 1); // -- передаём ему некоторые значения
	addNode (testlist, 2);
	addNode (testlist, 3);
	addNode (testlist, 4);
	addNode (testlist, 5);
	addNode (testlist, 13);
	
	for (int i = 0; i < testlist -> length; i++) // -- вывод элементов списка через цикл и функцию findNode
	{
		_intListNode *thenode = new _intListNode; // -- заводим временную переменную thenode
		*thenode = findNode(testlist, i); // -- передаём ему значения найденного элемента
		cout << i << ":" << thenode -> value << " "; // -- выводим в строчку номер и значение элемента
	}
	cout << "length " << testlist -> length << endl; // -- завершаем строку выводом длины списка
	
	insertNode (testlist, 8, 5); // -- добавим на позицию 5 элемент со значением 8
	
	for (int i = 0; i < testlist -> length; i++) // -- выводим список
	{
		_intListNode *thenode = new _intListNode;
		*thenode = findNode(testlist, i);
		cout << i << ":" << thenode -> value << " ";
	}
	cout << "length " << testlist -> length << endl;
	
	insertNode (testlist, 1, 0); // -- добавим в начало списка единицу
	
	for (int i = 0; i < testlist -> length; i++) // -- выводим список
	{
		_intListNode *thenode = new _intListNode;
		*thenode = findNode(testlist, i);
		cout << i << ":" << thenode -> value << " ";
	}
	cout << "length " << testlist -> length << endl;
	
	insertNode (testlist, 21, 8); // -- добавляем в конец 21
	
	for (int i = 0; i < testlist -> length; i++) // -- выводим
	{
		_intListNode *thenode = new _intListNode;
		*thenode = findNode(testlist, i);
		cout << i << ":" << thenode -> value << " ";
	}
	cout << "length " << testlist -> length << endl;
	
	cutNode (testlist); // -- убираем с конца элемент
	
	for (int i = 0; i < testlist -> length; i++) // -- выводим
	{
		_intListNode *thenode = new _intListNode;
		*thenode = findNode(testlist, i);
		cout << i << ":" << thenode -> value << " ";
	}
	cout << "length " << testlist -> length << endl;
	
	deleteNode(testlist, 4); // -- удаляем  элемент с номером 4
	
	for (int i = 0; i < testlist -> length; i++) // -- выводим
	{
		_intListNode *thenode = new _intListNode;
		*thenode = findNode(testlist, i);
		cout << i << ":" << thenode -> value << " ";
	}
	cout << "length " << testlist -> length << endl;
	// получаем красивую послеовательность, радуемся, что всё работает и 
	cout << "custom node number 6: " << getValue( testlist, 6); // -- завершаем проверкой getValue

	return 0;
}
